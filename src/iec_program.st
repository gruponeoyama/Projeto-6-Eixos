(* This file is generated by Sirius IEC61131 Editor *)
TYPE
  RPDO1_PULSE_T : STRUCT
    PULSE_1 : UINT;
    PULSE_2 : UINT;
    PULSE_3 : UINT;
    PULSE_4 : UINT;
  END_STRUCT;
  RPDO_SIO15_T : STRUCT
    PULSES_OUT : RPDO1_PULSE_T;
  END_STRUCT;
  TPDO1_PULSE_T : STRUCT
    PULSE_1 : UINT;
    PULSE_2 : UINT;
    PULSE_3 : UINT;
    PULSE_4 : UINT;
  END_STRUCT;
  TPDO_SIO15_T : STRUCT
    PULSES_IN : TPDO1_PULSE_T;
  END_STRUCT;
END_TYPE

FUNCTION_BLOCK FB_RESET_AXIS
  VAR
    FB_POWER:  MC_POWER;
    FB_RESET:  MC_RESET;
    r_trig_reset:  R_TRIG;
    FB_STATUS:  MC_READSTATUS;
  END_VAR
  VAR_INPUT
    axis_ref:  REF_TO AXIS_REF_T;
    b_reset:  BOOL;
    b_power:  BOOL;
  END_VAR
  VAR_OUTPUT
    axis_ok:  BOOL;
    sStatus:  string;
    stMessage:  string;
  END_VAR

  if (axis_ref <> null) then
     r_trig_reset(clk := b_reset);
  
     fb_reset.axis := axis_ref^.axisidx;
     fb_reset.execute := r_trig_reset.q;
     fb_reset();
  
     fb_status.axis := axis_ref^.axisidx;
     fb_status.enable := true;
     fb_status();
     axis_ok := true;
     if fb_status.valid then
        if fb_status.errorstop then
           axis_ok := false;
           sstatus := 'errorstop';
        elsif fb_status.disabled then
           axis_ok := false;
           sstatus := 'disabled';
        elsif fb_status.stopping then
           sstatus := 'stopping';
        elsif fb_status.homing then
           sstatus := 'homing';
        elsif fb_status.discretemotion then
           sstatus := 'discretemotion';
        elsif fb_status.continuousmotion then
           sstatus := 'continuousmotion';
        elsif fb_status.synchronizedmotion then
           sstatus := 'synchronizedmotion';
        elsif fb_status.standstill then
           sstatus := 'standstill';
        else
           axis_ok := false;
           sstatus := '???????????';
        END_IF;
     else
         sstatus := 'invalid';
     END_IF;
  
     fb_power.axis := axis_ref^.axisidx;
     fb_power.enablenegative := true;
     fb_power.enablepositive := true;
     fb_power.enable := not fb_status.errorstop and b_power;
     fb_power();
  END_IF;
  
  stmessage := mc_getaxiserrorstring(axis_ref^.axisidx, true);
END_FUNCTION_BLOCK

FUNCTION_BLOCK FB_HOMING
  VAR
    i_State:  INT := 0;
    FB_Stop:  MC_STOP;
    FB_MoveVel:  MC_MOVEVELOCITY;
    FB_SETPOS:  MC_SETPOSITION;
  END_VAR
  VAR_INPUT
    axis_ref:  REF_TO AXIS_REF_T;
    b_run:  BOOL;
    r_acceleration:  REAL;
    r_deceleration:  REAL;
    r_velocity:  REAL;
    r_wanted_pos:  REAL;
    b_direction:  BOOL;
    b_start:  BOOL;
    b_probe:  BOOL;
    b_set_fc:  BOOL;
  END_VAR
  VAR_OUTPUT
    b_done:  BOOL;
    b_active:  BOOL;
  END_VAR

  if (axis_ref <> null) then
    case i_state of
      0: (* start *)
        if b_start then
           b_done := false;
           b_active := true;
           fb_movevel.axis         := axis_ref^.axisidx;
           fb_movevel.acceleration := r_acceleration;
           fb_movevel.deceleration := r_deceleration;
           fb_movevel.velocity     := r_velocity;
           if b_direction then
              fb_movevel.direction := 1;
           else
              fb_movevel.direction := -1;
           END_IF;
           fb_movevel.execute := true;
           i_state := 1;
        END_IF;
  
      1:
        if not b_start or not b_probe then (* probe found, stop axis *)
           fb_stop.axis := fb_movevel.axis;
           fb_stop.deceleration := fb_movevel.deceleration;
           fb_stop.execute := true;
           i_state := 2;
        END_IF;
  
       if not fb_movevel.active then
           b_active := false;
           i_state := 0;
        END_IF;
  
      2:
        if fb_stop.error then
           b_active := false;
           i_state := 0;
        END_IF;
  
        if fb_stop.done then
           if not b_start then
              b_active := false;
              i_state := 0;
           else
              fb_movevel.velocity  := r_velocity * 0.2;
              fb_movevel.direction := fb_movevel.direction * -1;
              fb_movevel.execute   := true;
  
              (* probe lost during stopping, came back to probe *)
              if b_probe then
                 i_state := 5;
              else
                 i_state := 3;
              END_IF;
           END_IF;
        END_IF;
  
      3:
        if not b_start or b_probe then
           if b_start then
              if b_set_fc then
                 if b_direction then
                    axis_ref^.POSFW := r_wanted_pos;
                 else
                    axis_ref^.POSRV := r_wanted_pos;
                 END_IF;
              else
                 fb_setpos.axis := fb_movevel.axis;
                 fb_setpos.position := r_wanted_pos;
                 fb_setpos.execute := true;
              END_IF;
           END_IF;
           fb_stop.execute := true;
           i_state := 4;
        END_IF;
  
        if not fb_movevel.active then
           b_active := false;
           i_state := 0;
        END_IF;
  
      4:
        if fb_stop.error then
           b_active := false;
           i_state := 0;
        END_IF;
  
        if fb_stop.done then
           if b_start then
              b_done := true;
           END_IF;
           b_active := false;
           i_state := 0;
        END_IF;
  
      5:
        if not b_start then
           fb_stop.execute := true;
           i_state := 4;
        END_IF;
  
        if not b_probe then
           i_state := 3;
        END_IF;
  
        if not fb_movevel.active then
           b_active := false;
           i_state := 0;
        END_IF;
  
    END_CASE;
  END_IF;
  
  fb_movevel();
  fb_movevel.execute := false;
  
  fb_stop();
  fb_stop.execute := false;
  
  fb_setpos();
  fb_setpos.execute := false;
  
  b_active := i_state <> 0;
END_FUNCTION_BLOCK

FUNCTION_BLOCK FB_JOG
  VAR
    iState:  INT := 0;
    FB_Stop:  MC_STOP;
    FB_MoveAbs:  MC_MOVEABSOLUTE;
    FB_MoveVel:  MC_MOVEVELOCITY;
    r_trig_standstill:  R_TRIG;
  END_VAR
  VAR_INPUT
    axis_ref:  REF_TO AXIS_REF_T;
    bJogPos:  BOOL;
    bJogNeg:  BOOL;
    b_axisOk:  BOOL;
    acceleration:  REAL;
    deceleration:  REAL;
    velocity:  REAL;
  END_VAR
  VAR_OUTPUT
    bError:  BOOL;
    sStatus:  string;
    bBusy:  BOOL;
    bDone:  BOOL;
  END_VAR

  if (axis_ref <> null) then
    fb_moveAbs.axis  := axis_ref^.axisidx;
    fb_moveVel.axis  := axis_ref^.axisidx;
    fb_stop.axis     := axis_ref^.axisidx;
  
    (* refresh variables, velocity can be an analog input such potentiometer *)
    if (velocity > axis_ref^.MAXSPEED) then
       velocity := axis_ref^.MAXSPEED;
    END_IF;
    fb_moveabs.acceleration     := acceleration;
    fb_moveabs.deceleration     := deceleration;
    fb_moveabs.velocity         := velocity;
    fb_moveabs.continuousupdate := true;
  
    fb_moveVel.acceleration     := acceleration;
    fb_moveVel.deceleration     := deceleration;
    fb_moveVel.velocity         := velocity;
    fb_moveVel.continuousupdate := true;
  
    fb_stop.deceleration        := fb_moveabs.deceleration;
  
    (* if the state machine of the axis is in an error mode,
      and the jog state is not in idle condition:
      - give out error
      - kill other flags
    *)
    if istate > 1 then
      if (not b_axisok or fb_moveabs.error or fb_stop.error) then
        berror := true;
        bbusy  := false;
        bdone  := false;
        istate := 0;
      END_IF;
    END_IF;
  
    r_trig_standstill(clk := b_axisok);
    if r_trig_standstill.q then
      berror := false;
    END_IF;
  
    case istate of
    0:
      if (not bjogpos and not bjogneg) then
        istate := 1;
      END_IF;
  
    1:
      if (bjogpos and not bjogneg) then
        if axis_ref^.MODULE <> 0.0 then
           FB_MoveVel.DIRECTION := 1;
        else
           fb_moveabs.position := axis_ref^.posfw;
        END_IF;
        istate := 2;
      elsif (not bjogpos and bjogneg) then
        if axis_ref^.MODULE <> 0.0 then
           FB_MoveVel.DIRECTION := -1;
        else
           fb_moveabs.position := axis_ref^.posrv;
        END_IF;
        istate := 2;
      END_IF;
  
      (* give busy for at least one cicle, like plcopen want *)
      if (istate = 2) then
        bbusy  := true;
        bdone  := false;
        berror := false;
      END_IF;
  
    2:
      (* after the busy cicle, test if we really can do the job *)
      if axis_ref^.MODULE <> 0.0 then
         fb_moveVel.execute := true;
      else
         fb_moveabs.execute := true;
      END_IF;
      istate := 3;
  
    3:
       if (not fb_moveabs.active) and (not fb_moveVel.active) then
          bbusy  := false;
          bdone  := true;
          berror := false;
          fb_stop.execute := true;
          istate := 4; (* 0 *)
       elsif (not bjogpos and not bjogneg) then
          fb_stop.execute := true;
          istate := 4;
       END_IF;
  
    4:
      if fb_stop.done then
         bbusy  := false;
         bdone  := true;
         berror := false;
         istate := 0;
      END_IF;
    END_CASE;
  
    fb_moveabs();
    (* kill execute input *)
    fb_moveabs.execute := false;
    fb_moveabs();
  
    fb_moveVel();
    (* kill execute input *)
    fb_moveVel.execute := false;
    fb_moveVel();
  
    fb_stop();
    (* kill execute input *)
    fb_stop.execute := false;
    fb_stop();
  else
    sstatus := 'axis_ref = null';
    berror := true;
  END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK FB_MOVE
  VAR
    i_State:  INT := 0;
    FB_Stop:  MC_STOP;
    FB_MoveAbs:  MC_MOVEABSOLUTE;
  END_VAR
  VAR_INPUT
    axis_ref:  REF_TO AXIS_REF_T;
    b_run:  BOOL;
    r_acceleration:  REAL;
    r_deceleration:  REAL;
    r_velocity:  REAL;
    b_abs:  BOOL;
    r_match:  REAL;
    b_axisOk:  BOOL;
  END_VAR
  VAR_OUTPUT
    s_status:  string;
    b_done:  BOOL;
    b_active:  BOOL;
  END_VAR

  if (axis_ref <> null) then
     s_status := '';
    
     fb_moveabs.axis  := axis_ref^.axisidx;
     fb_stop.axis     := axis_ref^.axisidx;
    
     (* refresh variables, velocity can be an analog input such potentiometer *)
     fb_moveabs.acceleration     := r_acceleration;
     fb_moveabs.deceleration     := r_deceleration;
     if (axis_ref^.MODULE <> 0.0) then
       FB_MoveAbs.DIRECTION := 2;
     else
       FB_MoveAbs.DIRECTION := 1;
     END_IF;
     if (r_velocity > axis_ref^.MAXSPEED) then
        r_velocity := axis_ref^.MAXSPEED;
     END_IF;
     fb_moveabs.velocity         := r_velocity;
     fb_moveabs.continuousupdate := true;
     fb_stop.deceleration        := fb_moveabs.deceleration;
  
     if i_state > 1 then
       if (not b_axisok or fb_moveabs.error or fb_stop.error) then
         b_active := false;
         b_done  := false;
       END_IF;
     END_IF;
  
     case i_state of
     0:
       if (not b_run) then
         i_state := 1;
       END_IF;
   
     1:
       if b_run then
         if b_abs then               (* absolute position *)
           fb_moveabs.position       := r_match;
         else                        (* relative position *)
           fb_moveabs.position       := lreal_to_real(axis_ref^.abspos) + r_match;
         END_IF;
      
         if (axis_ref^.MODULE = 0.0) then
            if (fb_moveabs.position > axis_ref^.POSFW) then
               fb_moveabs.position := axis_ref^.POSFW;
            elsif (fb_moveabs.position < axis_ref^.POSRV) then
               fb_moveabs.position := axis_ref^.POSRV;
            END_IF;
         END_IF;
       
         (* give busy for at least one cicle, like plcopen want *)
         b_done  := false;
         b_active := true;
         i_state := 2;
       END_IF;
   
     2:
       (* aftern the busy cicle, test if we really can do the job *)
       fb_moveabs.execute := true;
       i_state := 3;
   
     3:
       if not fb_moveabs.active then
         b_done  := true;
         b_active := false;
         i_state := 0;
       elsif (not b_run) then
         fb_stop.execute := true;
         i_state := 4;
       END_IF;
   
     4:
       if fb_stop.done then
         b_done  := false;
         b_active := false;
         i_state := 0;
       END_IF;
     END_CASE;
  
     fb_moveabs();
     (* kill execute input *)
     fb_moveabs.execute := false;
     fb_moveabs();
   
     fb_stop();
     (* kill execute input *)
     fb_stop.execute := false;
     fb_stop();
  else
     s_status := 'axis_ref = null';
  END_IF;
END_FUNCTION_BLOCK

FUNCTION_BLOCK FB_TRANSFER
  VAR
    str_pos:  REAL;
    i_state:  INT := 0;
    fb_move_axis:  FB_MOVE;
    r_trig_start:  R_TRIG;
  END_VAR
  VAR_INPUT
    start:  BOOL;
    mode_abs:  BOOL;
    r_match:  REAL;
    r_offs:  REAL;
    axis_ref:  REF_TO AXIS_REF_T;
    r_acceleration:  REAL;
    r_deceleration:  REAL;
    r_velocity:  REAL;
    recupero_giochi:  REAL;
  END_VAR
  VAR_OUTPUT
    b_done:  BOOL := true;
    b_active:  BOOL;
    rel_pos:  REAL;
  END_VAR

  if (axis_ref <> null) then
    r_trig_start(CLK := start);
    case i_state of
      0: (* start *)
        if r_trig_start.q then
           b_done := false;
           b_active := true;
           str_pos := lreal_to_real(axis_ref^.abspos);
           fb_move_axis.b_axisok := true;
           fb_move_axis.b_abs := mode_abs;
           fb_move_axis.r_acceleration := r_acceleration;
           fb_move_axis.r_deceleration := r_deceleration;
           if (r_velocity > axis_ref^.MAXSPEED) then
              r_velocity := axis_ref^.MAXSPEED;
           END_IF;
           fb_move_axis.r_velocity := r_velocity;
           
           if mode_abs then
             fb_move_axis.r_match := r_match;
  
             if (((str_pos < r_match) and (recupero_giochi > 0.0))  or 
                 ((str_pos > r_match) and (recupero_giochi < 0.0))) then
               fb_move_axis.r_match := fb_move_axis.r_match + recupero_giochi;
               i_state := 1;
             else
               i_state := 2;
             END_IF;
           else
             if r_match >= 0.0 then
               fb_move_axis.r_match := r_match + r_offs;
             else
               fb_move_axis.r_match := r_match - r_offs;
             END_IF;
             
             if (((r_match >= 0.0) and (recupero_giochi > 0.0))  or 
                 ((r_match  < 0.0) and (recupero_giochi < 0.0))) then
               fb_move_axis.r_match := fb_move_axis.r_match + recupero_giochi;
               i_state := 1;
             else
               i_state := 2;
             END_IF;
           END_IF;
           fb_move_axis.b_run := true;
        END_IF;
  
      1:
        if not start then
           i_state := 0;
           fb_move_axis.b_run := false;
        END_IF;
  
        if fb_move_axis.b_done then
           fb_move_axis.b_run := false;
           fb_move_axis();
           if mode_abs then
              fb_move_axis.r_match := fb_move_axis.r_match - recupero_giochi; 
           else
              fb_move_axis.r_match := -recupero_giochi;
           END_IF;
           fb_move_axis.b_run := true;
           i_state := 2;
        elsif (not fb_move_axis.b_active) then
           fb_move_axis.b_run := false;
           i_state := 0;
        END_IF;
  
      2:
        if not start then
           i_state := 0;
           fb_move_axis.b_run := false;
        END_IF;
  
        if fb_move_axis.b_done then
           fb_move_axis.b_run := false;
           i_state := 0;
           b_done := fb_move_axis.b_done;
           b_active := false;
        elsif (not fb_move_axis.b_active) then
           fb_move_axis.b_run := false;
           i_state := 0;
        END_IF;
    END_CASE;
  
    rel_pos := lreal_to_real(axis_ref^.abspos) - str_pos;
  END_IF;
  fb_move_axis.axis_ref := axis_ref;
  fb_move_axis();
  b_active := i_state <> 0;
END_FUNCTION_BLOCK

FUNCTION_BLOCK FB_AXIS_MANAGER
  VAR
    homing:  FB_HOMING;
    rtrig_homing_done:  R_TRIG;
    jogging:  FB_JOG;
    transfer:  FB_TRANSFER;
    rtrig_trasf_done:  R_TRIG;
  END_VAR
  VAR_INPUT
    axis_ref:  REF_TO AXIS_REF_T;
    b_man:  BOOL;
    b_home_probe:  BOOL;
    b_jogFw:  BOOL;
    b_jogBv:  BOOL;
    b_axisOk:  BOOL;
  END_VAR
  VAR_INPUT  RETAIN
    r_home_pos:  REAL;
    r_homing_acc:  REAL;
    r_homing_dec:  REAL;
    r_homing_vel:  REAL;
    r_jog_vel:  REAL;
    r_jog_acc:  REAL;
    r_jog_dec:  REAL;
    b_abs:  BOOL;
    r_transf_pos:  REAL;
    r_transf_acc:  REAL;
    r_transf_dec:  REAL;
    r_transf_vel:  REAL;
    b_forward_homing:  BOOL;
  END_VAR
  VAR_OUTPUT
    r_transf_rel_pos:  REAL;
  END_VAR
  VAR_IN_OUT
    b_start_homing:  BOOL;
    b_homed:  BOOL;
    b_start_transf:  BOOL;
  END_VAR

  (* homing *)
  homing.axis_ref       := axis_ref;
  homing.b_start        := b_start_homing and b_axisOk;
  homing.b_probe        := b_home_probe;
  homing.b_direction    := b_forward_homing;
  homing.r_wanted_pos   := r_home_pos;
  homing.r_acceleration := r_homing_acc;
  homing.r_deceleration := r_homing_dec;
  homing.r_velocity     := r_homing_vel;
  homing();
  rtrig_homing_done(clk := not homing.b_active);
  if (rtrig_homing_done.q) then
     (* succesfully homed *)
     if b_start_homing then
       b_homed := homing.b_done;
     END_IF;
     b_start_homing := false;
  END_IF;
  
  (* transfer *)
  transfer.axis_ref        := axis_ref;
  transfer.start           := b_start_transf and b_axisOk;
  transfer.mode_abs        := b_abs;
  (* desidered position *)
  transfer.r_match         := r_transf_pos;
  transfer.r_acceleration  := r_transf_acc;
  transfer.r_deceleration  := r_transf_dec;
  transfer.r_velocity      := r_transf_vel;
  transfer();
  (* posicao relativa para GUI *)
  r_transf_rel_pos := transfer.rel_pos;
  rtrig_trasf_done(clk := not transfer.b_active);
  if (rtrig_trasf_done.q) then
     b_start_transf := false;
  END_IF;
  
  (* manual jogging *)
  if b_man then
    jogging.axis_ref := axis_ref;
    jogging.b_axisOk := b_axisOk;
    (* start jogging flags *)
    jogging.bJogPos := b_jogFw;
    jogging.bJogNeg := b_jogBv;
    jogging.velocity := r_jog_vel;
    jogging.acceleration := r_jog_acc;
    jogging.deceleration := r_jog_dec;
    jogging();
  END_IF;
END_FUNCTION_BLOCK

FUNCTION SH_DOWN : BOOL
  VAR
    error_msg:  string;
  END_VAR
  VAR_INPUT
    error_code:  INT;
    verbose:  SINT;
  END_VAR

  if verbose <> 0 then
     (* force a program stop if debugger is present *)
     debugBreak();
     error_msg := CONCAT(IN1 := 'sh_down ', IN2 := INT_TO_STRING(error_code));
     (* display an error message on IEC editor and HMI *)
    (* guiMsg(STR := error_msg);*)
     GUIMSG(TEXT := error_msg);
  END_IF;
END_FUNCTION

PROGRAM alarms
  VAR_EXTERNAL
    g_b_stop_fw_ls_C:  BOOL;
    g_b_stop_fw_ls_B:  BOOL;
    g_b_stop_fw_ls_A:  BOOL;
    g_b_stop_fw_ls_Z:  BOOL;
    g_b_stop_fw_ls_Y:  BOOL;
    g_b_stop_fw_ls_X:  BOOL;
    g_b_stop_rv_ls_C:  BOOL;
    g_b_stop_rv_ls_B:  BOOL;
    g_b_stop_rv_ls_A:  BOOL;
    g_b_stop_rv_ls_Z:  BOOL;
    g_b_stop_rv_ls_Y:  BOOL;
    g_b_stop_rv_ls_X:  BOOL;
    g_b_stop_probeC:  BOOL;
    g_b_stop_probeB:  BOOL;
    g_b_stop_probeA:  BOOL;
    g_b_stop_probeZ:  BOOL;
    g_b_stop_probeY:  BOOL;
    g_b_stop_probeX:  BOOL;
    g_b_stop_disabled:  BOOL;
    g_b_stop_errorstop:  BOOL;
    g_b_stop_power_off:  BOOL;
    g_si_verbose:  SINT;
    g_axis_manager_x:  FB_AXIS_MANAGER;
    g_axis_manager_y:  FB_AXIS_MANAGER;
    g_axis_manager_z:  FB_AXIS_MANAGER;
    g_axis_manager_a:  FB_AXIS_MANAGER;
    g_axis_manager_b:  FB_AXIS_MANAGER;
    g_axis_manager_c:  FB_AXIS_MANAGER;
  END_VAR
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    fb_reset_axis_x:  FB_RESET_AXIS;
    fb_reset_axis_y:  FB_RESET_AXIS;
    fb_reset_axis_z:  FB_RESET_AXIS;
    fb_reset_axis_a:  FB_RESET_AXIS;
    fb_reset_axis_b:  FB_RESET_AXIS;
    fb_reset_axis_c:  FB_RESET_AXIS;
    g_b_driverXOk:  BOOL;
    g_b_driverYOk:  BOOL;
    g_b_driverZOk:  BOOL;
    g_b_driverAOk:  BOOL;
    g_b_driverBOk:  BOOL;
    g_b_driverCOk:  BOOL;
    g_b_powerOn:  BOOL;
    g_b_machineOk:  BOOL;
    g_b_reset_axis:  BOOL;
    g_b_auto:  BOOL;
    g_b_alarm_power_off:  BOOL;
    g_b_alarm_errorstop:  BOOL;
    g_b_alarm_disabled:  BOOL;
    g_b_alarm_probeX:  BOOL;
    g_b_alarm_probeY:  BOOL;
    g_b_alarm_probeZ:  BOOL;
    g_b_alarm_probeA:  BOOL;
    g_b_alarm_probeB:  BOOL;
    g_b_alarm_probeC:  BOOL;
    g_b_alarm_rv_ls_X:  BOOL;
    g_b_alarm_rv_ls_Y:  BOOL;
    g_b_alarm_rv_ls_Z:  BOOL;
    g_b_alarm_rv_ls_A:  BOOL;
    g_b_alarm_rv_ls_B:  BOOL;
    g_b_alarm_rv_ls_C:  BOOL;
    g_b_alarm_fw_ls_X:  BOOL;
    g_b_alarm_fw_ls_Y:  BOOL;
    g_b_alarm_fw_ls_Z:  BOOL;
    g_b_alarm_fw_ls_A:  BOOL;
    g_b_alarm_fw_ls_B:  BOOL;
    g_b_alarm_fw_ls_C:  BOOL;
    g_b_reset_stop_causes:  BOOL;
    g_b_reset_alarms:  BOOL;
    g_b_stop_auto:  BOOL;
    g_b_alarm_stop_auto:  BOOL;
    g_b_alarm_moving:  BOOL;
    g_b_stop_auto_triggered:  BOOL;
    g_b_alarm_driverXOk:  BOOL;
    g_b_alarm_driverYOk:  BOOL;
    g_b_alarm_driverZOk:  BOOL;
    g_b_alarm_driverAOk:  BOOL;
    g_b_alarm_driverBOk:  BOOL;
    g_b_alarm_driverCOk:  BOOL;
    g_b_start_cnc:  BOOL;
  END_VAR
  VAR
    r_trig_power_on:  R_TRIG;
    r_trig_power_off:  R_TRIG;
    r_trig_errorstop:  R_TRIG;
    r_trig_disabled:  R_TRIG;
    ton_reset_axis:  TON;
    b_clk:  BOOL;
  END_VAR

  (* Power ON *)
  r_trig_power_on(clk := g_b_machineOk);
  if r_trig_power_on.q then 
    ton_reset_axis.PT := t#1s;
    ton_reset_axis.IN := true;
    g_b_alarm_power_off := false;
  END_IF;
  
  (* Force all axis delayed reset at power on *)
  if ton_reset_axis.q then                    
    ton_reset_axis.IN := false;
    g_b_reset_axis := true;
  END_IF;
  ton_reset_axis();
  
  if g_b_machineOk then
     (* Automatic cycle active and active error in PLC Motion *)
     if g_b_auto then
        (* active error in PLC Motion *)
        b_clk := fb_reset_axis_x.fb_status.errorstop or
                 fb_reset_axis_y.fb_status.errorstop or
                 fb_reset_axis_z.fb_status.errorstop or
                 fb_reset_axis_a.fb_status.errorstop or
                 fb_reset_axis_b.fb_status.errorstop or
                 fb_reset_axis_c.fb_status.errorstop;
        r_trig_errorstop(clk := b_clk);
        (* Axis is being disabled in PLC Motion *)
        b_clk := fb_reset_axis_x.fb_status.disabled or
                 fb_reset_axis_y.fb_status.disabled or
                 fb_reset_axis_z.fb_status.disabled or
                 fb_reset_axis_a.fb_status.disabled or
                 fb_reset_axis_b.fb_status.disabled or
                 fb_reset_axis_c.fb_status.disabled;
        r_trig_disabled(clk := b_clk);
  
        if r_trig_errorstop.q then
           g_b_alarm_errorstop := true;
           g_b_stop_errorstop := true;
           sh_down(1, g_si_verbose);
           g_b_powerOn := false;                    
        END_IF;                       
  
        if r_trig_disabled.q then
           g_b_alarm_disabled := true;
           g_b_stop_disabled := true;
           sh_down(2, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
     
     if not g_b_driverXOk then
       g_b_alarm_driverXOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_x.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_x.b_home_probe and (axis_x.realspeed <> 0.0) then
           g_b_alarm_probeX := true;
           g_b_stop_probeX := true;
           sh_down(3, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_x.FCRV and (axis_x.realspeed < 0.0) then
           g_b_alarm_rv_ls_X := true;
           g_b_stop_rv_ls_X := true;
           sh_down(4, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_x.FCFW and (axis_x.realspeed > 0.0) then
           g_b_alarm_fw_ls_X := true;
           g_b_stop_fw_ls_X := false;
           sh_down(5, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  
     if not g_b_driverYOk then
       g_b_alarm_driverYOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_y.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_y.b_home_probe and (axis_y.realspeed <> 0.0) then
           g_b_alarm_probeY := true;
           g_b_stop_probeY := true;
           sh_down(6, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_y.FCRV and (axis_y.realspeed < 0.0) then
           g_b_alarm_rv_ls_y := true;
           g_b_stop_rv_ls_y := true;
           sh_down(7, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_y.FCFW and (axis_y.realspeed > 0.0) then
           g_b_alarm_fw_ls_y := true;
           g_b_stop_fw_ls_y := false;
           sh_down(8, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  
     if not g_b_driverZOk then
       g_b_alarm_driverZOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_z.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_z.b_home_probe and (axis_z.realspeed <> 0.0) then
           g_b_alarm_probeZ := true;
           g_b_stop_probeZ := true;
           sh_down(9, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_z.FCRV and (axis_z.realspeed < 0.0) then
           g_b_alarm_rv_ls_z := true;
           g_b_stop_rv_ls_z := true;
           sh_down(10, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_z.FCFW and (axis_z.realspeed > 0.0) then
           g_b_alarm_fw_ls_z := true;
           g_b_stop_fw_ls_z := false;
           sh_down(11, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  
     if not g_b_driverAOk then
       g_b_alarm_driverAOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_a.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_a.b_home_probe and (axis_a.realspeed <> 0.0) then
           g_b_alarm_probeA := true;
           g_b_stop_probeA := true;
           sh_down(12, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_a.FCRV and (axis_a.realspeed < 0.0) then
           g_b_alarm_rv_ls_a := true;
           g_b_stop_rv_ls_a := true;
           sh_down(13, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_a.FCFW and (axis_a.realspeed > 0.0) then
           g_b_alarm_fw_ls_a := true;
           g_b_stop_fw_ls_a := false;
           sh_down(14, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  
     if not g_b_driverBOk then
       g_b_alarm_driverBOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_b.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_b.b_home_probe and (axis_b.realspeed <> 0.0) then
           g_b_alarm_probeB := true;
           g_b_stop_probeB := true;
           sh_down(15, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_b.FCRV and (axis_b.realspeed < 0.0) then
           g_b_alarm_rv_ls_b := true;
           g_b_stop_rv_ls_b := true;
           sh_down(16, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_b.FCFW and (axis_b.realspeed > 0.0) then
           g_b_alarm_fw_ls_b := true;
           g_b_stop_fw_ls_b := false;
           sh_down(14, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  
     if not g_b_driverCOk then
       g_b_alarm_driverCOk := true;
     END_IF;
     (* when not homing, check hardware limit swich *)
     if not g_axis_manager_c.b_start_homing then
        (* home probe  *)
        if not g_axis_manager_c.b_home_probe and (axis_c.realspeed <> 0.0) then
           g_b_alarm_probeC := true;
           g_b_stop_probeC := true;
           sh_down(16, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* backwards limit switch  *)
        if axis_c.FCRV and (axis_c.realspeed < 0.0) then
           g_b_alarm_rv_ls_c := true;
           g_b_stop_rv_ls_c := true;
           sh_down(17, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
  
        (* forward limit switch  *)
        if axis_c.FCFW and (axis_c.realspeed > 0.0) then
           g_b_alarm_fw_ls_c := true;
           g_b_stop_fw_ls_c := false;
           sh_down(18, g_si_verbose);
           g_b_powerOn := false;
        END_IF;
     END_IF;
  END_IF;
  
   (* reset stop cause/reason *)
  if g_b_reset_stop_causes then
     g_b_reset_stop_causes := false;
  
     g_b_stop_errorstop := false;
     g_b_stop_disabled  := false;
  
     g_b_stop_probeX  := false;
     g_b_stop_probeY  := false;
     g_b_stop_probeZ  := false;
     g_b_stop_probeA  := false;
     g_b_stop_probeB  := false;
     g_b_stop_probeC  := false;
  
     g_b_stop_rv_ls_X := false;
     g_b_stop_rv_ls_Y := false;
     g_b_stop_rv_ls_Z := false;
     g_b_stop_rv_ls_A := false;
     g_b_stop_rv_ls_B := false;
     g_b_stop_rv_ls_C := false;
  
     g_b_stop_fw_ls_X := false;
     g_b_stop_fw_ls_Y := false;
     g_b_stop_fw_ls_Z := false;
     g_b_stop_fw_ls_A := false;
     g_b_stop_fw_ls_B := false;
     g_b_stop_fw_ls_X := false;
     
     g_b_stop_auto_triggered := false;
     g_b_stop_power_off      := false;
  END_IF;
  
  (* reset alarms *)
  if g_b_reset_alarms then
     g_b_reset_alarms := false;
  
     g_b_alarm_errorstop := false;
     g_b_alarm_disabled  := false;
     
     g_b_alarm_probeX    := false;
     g_b_alarm_probeY    := false;
     g_b_alarm_probeZ    := false;
     g_b_alarm_probeA    := false;
     g_b_alarm_probeB    := false;
     g_b_alarm_probeC    := false;
  
     g_b_alarm_rv_ls_X   := false;
     g_b_alarm_rv_ls_Y   := false;
     g_b_alarm_rv_ls_Z   := false;
     g_b_alarm_rv_ls_A   := false;
     g_b_alarm_rv_ls_B   := false;
     g_b_alarm_rv_ls_C   := false;
  
     g_b_alarm_fw_ls_X   := false;
     g_b_alarm_fw_ls_Y   := false;
     g_b_alarm_fw_ls_Z   := false;
     g_b_alarm_fw_ls_A   := false;
     g_b_alarm_fw_ls_B   := false;
     g_b_alarm_fw_ls_C   := false;
  
     g_b_alarm_driverXOk := false;
     g_b_alarm_driverYOk := false;
     g_b_alarm_driverZOk := false;
     g_b_alarm_driverAOk := false;
     g_b_alarm_driverBOk := false;
     g_b_alarm_driverCOk := false;
     
     g_b_alarm_stop_auto := false;
     g_b_alarm_moving    := false;
  END_IF;
  
  (* Power loss *)
  r_trig_power_off(clk := not g_b_machineOk);
  if r_trig_power_off.q then
    g_b_auto           := false;
  
    g_axis_manager_x.b_start_homing := false;
    g_axis_manager_y.b_start_homing := false;
    g_axis_manager_z.b_start_homing := false;
    g_axis_manager_a.b_start_homing := false;
    g_axis_manager_b.b_start_homing := false;
    g_axis_manager_c.b_start_homing := false;
  
    g_axis_manager_x.b_start_transf := false;
    g_axis_manager_y.b_start_transf := false;
    g_axis_manager_z.b_start_transf := false;
    g_axis_manager_a.b_start_transf := false;
    g_axis_manager_b.b_start_transf := false;
    g_axis_manager_c.b_start_transf := false;
           
    g_b_start_cnc := false;
    
    if g_b_powerOn then
       g_b_alarm_power_off := true;
       g_b_stop_power_off := true;
    END_IF;
     g_b_powerOn := true; 
  END_IF;
END_PROGRAM

PROGRAM axes_manager
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    fb_reset_axis_x:  FB_RESET_AXIS;
    fb_reset_axis_y:  FB_RESET_AXIS;
    fb_reset_axis_z:  FB_RESET_AXIS;
    fb_reset_axis_a:  FB_RESET_AXIS;
    fb_reset_axis_b:  FB_RESET_AXIS;
    fb_reset_axis_c:  FB_RESET_AXIS;
    g_b_man:  BOOL;
  END_VAR
  VAR_EXTERNAL
    g_axis_manager_x:  FB_AXIS_MANAGER;
    g_axis_manager_y:  FB_AXIS_MANAGER;
    g_axis_manager_z:  FB_AXIS_MANAGER;
    g_axis_manager_a:  FB_AXIS_MANAGER;
    g_axis_manager_b:  FB_AXIS_MANAGER;
    g_axis_manager_c:  FB_AXIS_MANAGER;
  END_VAR

  g_axis_manager_x.b_axisOk := (not fb_reset_axis_x.fb_status.errorstop) and (not fb_reset_axis_x.fb_status.disabled);
  g_axis_manager_x.b_man    := g_b_man;
  g_axis_manager_x ();
  
  g_axis_manager_y.b_axisOk := (not fb_reset_axis_y.fb_status.errorstop) and (not fb_reset_axis_y.fb_status.disabled);
  g_axis_manager_y.b_man    := g_b_man;
  g_axis_manager_y ();
  
  g_axis_manager_z.b_axisOk := (not fb_reset_axis_z.fb_status.errorstop) and (not fb_reset_axis_z.fb_status.disabled);
  g_axis_manager_z.b_man    := g_b_man;
  g_axis_manager_z ();
  
  g_axis_manager_a.b_axisOk := (not fb_reset_axis_a.fb_status.errorstop) and (not fb_reset_axis_a.fb_status.disabled);
  g_axis_manager_a.b_man    := g_b_man;
  g_axis_manager_a ();
  
  g_axis_manager_b.b_axisOk := (not fb_reset_axis_b.fb_status.errorstop) and (not fb_reset_axis_b.fb_status.disabled);
  g_axis_manager_b.b_man    := g_b_man;
  g_axis_manager_b ();
  
  g_axis_manager_c.b_axisOk := (not fb_reset_axis_c.fb_status.errorstop) and (not fb_reset_axis_c.fb_status.disabled);
  g_axis_manager_c.b_man    := g_b_man;
  g_axis_manager_c ();
END_PROGRAM

PROGRAM cnc_main
  VAR
    i_calculation_in_progress:  BOOL;
    i_calculation_percent:  USINT;
  END_VAR
  VAR_EXTERNAL
    cnc_parser_fb:  CNC_PARSER;
    cnc_read_fb:  CNC_READFILE;
  END_VAR

  (* 
  HMI progressbar on "work in progress", 
  refer to :
    default_800x480.ui -> qhmiroundprogressbar 
  *)
  if cnc_parser_fb.execute then
     i_calculation_in_progress := true;
     i_calculation_percent := cnc_parser_fb.percent;
  elsif cnc_read_fb.execute then
     i_calculation_in_progress := true;
     i_calculation_percent := cnc_read_fb.percent;
  else
     i_calculation_in_progress := false;
  END_IF;
END_PROGRAM

PROGRAM fast_cnc
  VAR
    r_pos_to_go_c:  REAL;
    r_pos_to_go_b:  REAL;
    r_pos_to_go_a:  REAL;
    r_pos_to_go_z:  REAL;
    r_pos_to_go_y:  REAL;
    r_pos_to_go_x:  REAL;
    b_feedmove:  BOOL;
    i_cnc_state:  INT;
    r_trig_auto:  R_TRIG;
    f_trig_auto:  F_TRIG;
    loc_lineinfo:  CNC_LINEINFO;
    f_trig_active:  F_TRIG;
    ton_execgcode:  TON;
  END_VAR
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    g_b_auto:  BOOL;
    g_b_start_cnc:  BOOL;
  END_VAR
  VAR_EXTERNAL
    cnc_exec_fb:  CNC_EXECGCODE;
    g_b_need_reset:  BOOL;
  END_VAR
  VAR  RETAIN
    b_spindle_on:  BOOL;
    b_dwell:  BOOL;
  END_VAR

  r_trig_auto(clk := g_b_start_cnc);
  f_trig_auto(clk := g_b_start_cnc);
  f_trig_active(clk := cnc_exec_fb.active);
  
  if cnc_exec_fb.interpolating then
     (* from GCode virtual positions to physical axes *)
     axis_x.actspa := real_to_lreal(cnc_exec_fb.actPos[0]);
     axis_y.actspa := real_to_lreal(cnc_exec_fb.actPos[1]);
     axis_z.actspa := real_to_lreal(cnc_exec_fb.actPos[2]);
     axis_a.actspa := real_to_lreal(cnc_exec_fb.actPos[3]);
     axis_b.actspa := real_to_lreal(cnc_exec_fb.actPos[4]);
     axis_c.actspa := real_to_lreal(cnc_exec_fb.actPos[5]);
  END_IF;
  
  (* check for errors *)
  if (i_cnc_state <> 0) and
     (cnc_exec_fb.error) then
     cnc_exec_fb.stop := true; 
     i_cnc_state := 0;
     g_b_auto := false;
  END_IF;
  
  (* get information about actual GCode execution *)
  CNC_GETLINEINFO(LINEINFO_PTR := ref(loc_lineinfo), LINEINFO_ARRAY := cnc_exec_fb.lineInfo, LINE := cnc_exec_fb.gCodeLine);
  if cnc_exec_fb.active then
    b_feedmove := (loc_lineinfo.CMDTYPE = QSTRAIGHT_FEED) or (loc_lineinfo.CMDTYPE = QARC_FEED);
  else  
    b_feedmove := false;
  END_IF;                                                
  
  (* started now *)
  if r_trig_auto.q then
     (* not valid line, require a reset *)
     if ((cnc_exec_fb.gCodeLine < 0) or (cnc_exec_fb.gCodeLine > cnc_exec_fb.lineInfo_len)) then
        cnc_exec_fb.gCodeLine := 0;
        i_cnc_state := 0;
        g_b_need_reset := true;
     END_IF;
     
     if g_b_need_reset then
        g_b_start_cnc := false;
     else
        (* restart from current pos *)
        (* from physical axes positions to GCode virtual positions *)
        cnc_exec_fb.actPos[0] := lreal_to_real(axis_x.actSpa);
        cnc_exec_fb.actPos[1] := lreal_to_real(axis_y.actSpa);
        cnc_exec_fb.actPos[2] := lreal_to_real(axis_z.actSpa);
        cnc_exec_fb.actPos[3] := lreal_to_real(axis_a.actSpa);
        cnc_exec_fb.actPos[4] := lreal_to_real(axis_b.actSpa);
        cnc_exec_fb.actPos[5] := lreal_to_real(axis_c.actSpa);
        cnc_exec_fb.execute := true;
     END_IF;
  END_IF;
  
  (* GCode is working, look at extGCodeNeed boolean flag *)
  if cnc_exec_fb.active then
     b_dwell := (loc_lineinfo.CMDTYPE = QDWELL);
     if cnc_exec_fb.extGCodeNeed then
        (* delay for spindle ON/OFF *)
        ton_execgcode.pt := t#2s;
        (* need to stop spindle *)
        if loc_lineinfo.cmdType = QSTOP_SPINDLE then
           ton_execgcode(IN := cnc_exec_fb.extGCodeNeed);
           cnc_exec_fb.extGCodeDone := ton_execgcode.q;
           if cnc_exec_fb.extGCodeDone then
             b_spindle_on := false;
           END_IF;
        (* need to start spindle *)
        elsif (loc_lineinfo.cmdType = QSTART_SPINDLE_CW) or
              (loc_lineinfo.cmdType = QSTART_SPINDLE_CCW) then
           ton_execgcode(IN := cnc_exec_fb.extGCodeNeed);
           cnc_exec_fb.extGCodeDone := ton_execgcode.q;
           b_spindle_on := true;
        else
           ton_execgcode(IN := false);
           cnc_exec_fb.extGCodeDone := true;
        END_IF;
     else
        ton_execgcode(IN := false);
     END_IF;
  END_IF;
  
  (* Stopped now *)
  if f_trig_auto.q then 
     i_cnc_state := 0;
     if cnc_exec_fb.active then
        cnc_exec_fb.stop := true;
     END_IF;
  END_IF;
  
  if cnc_exec_fb.group_state = NEED_RESET then
     if (not cnc_exec_fb.reset) then
       (* need reset from HMI *)
       g_b_need_reset := true;
     END_IF;
  END_IF;
  
  (* GCode execution finished or stopped *)
  if f_trig_active.q then 
     if g_b_start_cnc then
        g_b_start_cnc := false;
     END_IF;
  END_IF;
  
  (* 
    position to reach for HMI 
    refer to:
    default_800x480.ui -> qHmiLabel_23
  *)
  if ((loc_lineinfo.CMDTYPE = QSTRAIGHT_TRAVERSE) or 
      (loc_lineinfo.CMDTYPE = QSTRAIGHT_FEED) or 
      (loc_lineinfo.CMDTYPE = QARC_FEED)) then
    r_pos_to_go_x := loc_lineinfo.endPos[0];
    r_pos_to_go_y := loc_lineinfo.endPos[1];
    r_pos_to_go_z := loc_lineinfo.endPos[2];
    r_pos_to_go_a := loc_lineinfo.endPos[3];
    r_pos_to_go_b := loc_lineinfo.endPos[4];
    r_pos_to_go_c := loc_lineinfo.endPos[5];
  else
    r_pos_to_go_x := 0.0;
    r_pos_to_go_y := 0.0;
    r_pos_to_go_z := 0.0;
    r_pos_to_go_a := 0.0;
    r_pos_to_go_b := 0.0;
    r_pos_to_go_c := 0.0;
  END_IF;
  
  if b_spindle_on then
     (* first line, we are starting a new job, forget machining status *)
     if (cnc_exec_fb.gCodeLine = 0) then
       b_spindle_on := false;
       b_dwell      := false;
     END_IF;
  END_IF;
END_PROGRAM

PROGRAM fast_io
  VAR
    raw_diff_b:  DINT;
    raw_out_b:  DINT;
    raw_in_b:  DINT;
    ui_raw_diff:  UINT;
    b_enable_io:  BOOL := true;
  END_VAR
  VAR_EXTERNAL
    g_b_machineOk:  BOOL;
    g_b_powerOn:  BOOL;
    g_b_powerOk:  BOOL;
    g_b_driverCOk:  BOOL;
    g_b_driverBOk:  BOOL;
    g_b_driverAOk:  BOOL;
    g_b_driverZOk:  BOOL;
    g_b_driverYOk:  BOOL;
    g_b_driverXOk:  BOOL;
    g_di_rawInC:  DINT;
    g_di_rawOutC:  DINT;
    g_di_rawInB:  DINT;
    g_di_rawOutB:  DINT;
    g_di_rawInA:  DINT;
    g_di_rawOutA:  DINT;
    g_di_rawInZ:  DINT;
    g_di_rawOutZ:  DINT;
    g_di_rawInY:  DINT;
    g_di_rawOutY:  DINT;
    g_di_rawInX:  DINT;
    g_di_rawOutX:  DINT;
    TARGET_DEB_I0:  TARGET_DEB_T;
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    SIO15:  CAN_NODE_T;
    local_pwm:  TARGET_DEB_PWM_T;
    g_b_simulation:  BOOL;
    SIO15_RPDO:  RPDO_SIO15_T;
  END_VAR

  (* input/output management *)
  if g_b_simulation then
    TARGET_DEB_I0.DEBOK := true;
  
    axis_x.drvok := true;
    axis_y.drvok := true;
    axis_z.drvok := true;
    axis_a.drvok := true;
    axis_b.drvok := true;
    axis_c.drvok := true;
  elsif b_enable_io then
    g_b_driverXOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_driverYOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_driverZOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_driverAOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_driverBOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_driverCOk := TARGET_DEB_I0.DEBOK and sio15.canok;
    g_b_powerOn := TARGET_DEB_I0.DEBOK; 
  END_IF;
  
  (* hardware/physical limit switch *)
  axis_x.fcFw   := false;
  axis_x.fcRv   := false;
  (* PLS output generation for stepper motor *)
  ui_raw_diff      := DINT_TO_UINT(g_di_rawOutX - g_di_rawInX);
  local_pwm.m16_17 := local_pwm.m16_17 + ui_raw_diff;
  g_di_rawInX      := g_di_rawOutX;
  
  (* PLS output generation for stepper motor *)
  ui_raw_diff      := DINT_TO_UINT(g_di_rawOutY - g_di_rawInY);
  local_pwm.m18_19 := local_pwm.m18_19 + ui_raw_diff;
  g_di_rawInY      := g_di_rawOutY;
  
  (* PLS output generation for stepper motor *)
  ui_raw_diff      := DINT_TO_UINT(g_di_rawOutZ - g_di_rawInZ);
  local_pwm.m36_37 := local_pwm.m36_37 + ui_raw_diff;
  g_di_rawInZ      := g_di_rawOutZ;
  
  (* PLS output generation for stepper motor *)
  ui_raw_diff      := DINT_TO_UINT(g_di_rawOutA - g_di_rawInA);
  local_pwm.m38_39 := local_pwm.m38_39 + ui_raw_diff;
  g_di_rawInA      := g_di_rawOutA;
  
  (* PLS output generation for stepper motor *)
  raw_in_b := g_di_rawInB;
  raw_out_b := g_di_rawOutB;
  raw_diff_b := g_di_rawOutB - g_di_rawInB;
  ui_raw_diff               := DINT_TO_UINT(g_di_rawOutB - g_di_rawInB);
  sio15_rpdo.pulses_out.pulse_1 := sio15_rpdo.pulses_out.pulse_1 + ui_raw_diff;
  g_di_rawInB               := g_di_rawOutB;  
  
  (* PLS output generation for stepper motor *)
  ui_raw_diff               := DINT_TO_UINT(g_di_rawOutC - g_di_rawInC);
  sio15_rpdo.pulses_out.pulse_2 := sio15_rpdo.pulses_out.pulse_2 + ui_raw_diff;
  g_di_rawInC               := g_di_rawOutC;
  
                   (* digital output what allow power-on *)
  g_b_machineOk := g_b_powerOn and 
                   (* digital input machine powerd-on *)
                   g_b_powerOk and 
                   (* local I/O ok *)
                   TARGET_DEB_I0.DEBOK and 
                   (* remote CAN I/O ok *)
                   sio15.canok;
END_PROGRAM

PROGRAM init
  VAR_EXTERNAL
    g_b_stop_auto:  BOOL;
    g_b_driverCOk:  BOOL;
    g_b_driverBOk:  BOOL;
    g_b_driverAOk:  BOOL;
    g_b_driverZOk:  BOOL;
    g_b_driverYOk:  BOOL;
    g_b_driverXOk:  BOOL;
    g_di_rawInC:  DINT;
    g_di_rawOutC:  DINT;
    g_di_rawInB:  DINT;
    g_di_rawOutB:  DINT;
    g_di_rawInA:  DINT;
    g_di_rawOutA:  DINT;
    g_di_rawInZ:  DINT;
    g_di_rawOutZ:  DINT;
    g_di_rawInY:  DINT;
    g_di_rawOutY:  DINT;
    g_di_rawInX:  DINT;
    g_di_rawOutX:  DINT;
    TARGET_DEB_I0:  TARGET_DEB_T;
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    g_b_simulation:  BOOL;
    fb_reset_axis_x:  FB_RESET_AXIS;
    fb_reset_axis_y:  FB_RESET_AXIS;
    fb_reset_axis_z:  FB_RESET_AXIS;
    fb_reset_axis_a:  FB_RESET_AXIS;
    fb_reset_axis_b:  FB_RESET_AXIS;
    fb_reset_axis_c:  FB_RESET_AXIS;
  END_VAR
  VAR_EXTERNAL
    g_b_moving_x:  BOOL;
    g_b_moving_y:  BOOL;
    g_b_moving_z:  BOOL;
    g_b_moving_a:  BOOL;
    g_b_moving_b:  BOOL;
    g_b_moving_c:  BOOL;
    g_axis_manager_x:  FB_AXIS_MANAGER;
    g_axis_manager_y:  FB_AXIS_MANAGER;
    g_axis_manager_z:  FB_AXIS_MANAGER;
    g_axis_manager_a:  FB_AXIS_MANAGER;
    g_axis_manager_b:  FB_AXIS_MANAGER;
    g_axis_manager_c:  FB_AXIS_MANAGER;
    cnc_exec_fb:  CNC_EXECGCODE;
  END_VAR

  (* PLC is running in "simulation" mode ? *)
  g_b_simulation := sir_get_plcsimulation();
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_x.modeProf      := 0;
  (* Max speed units per seconds, 20000 millmeters = 20 meters per second *)
  axis_x.maxSpeed      := 20000.0 / 60.0;
  (* Maximum acceleration *)
  axis_x.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_x.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_x.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_x.coe_enc <= 0.0) or (axis_x.coe_enc > 0.0)) then
    axis_x.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_x.simul         := false;
  (* setting up cubic interpolation *)
  axis_x.intrate       := 5;
  axis_x.segtime       := 0.02;
  (* set point, target position *)
  axis_x.ref_to_rawOut := ref(g_di_rawOutX);
  (* actual position *)
  axis_x.ref_to_rawIn  := ref(g_di_rawInX);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_x.axis_ref  := ref(axis_x);
  g_axis_manager_x.axis_ref := ref(axis_x);
  (* software limit switch *)
  axis_x.posRv := -2000.0;
  axis_x.posFw := 2000.0;
  (* check for axis acceleration value *)
  if g_axis_manager_x.r_homing_acc <= 0.0 then
     g_axis_manager_x.r_homing_acc := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_homing_dec <= 0.0 then
     g_axis_manager_x.r_homing_dec := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_homing_vel <= 0.0 then
     g_axis_manager_x.r_homing_vel := axis_x.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_x.r_transf_acc <= 0.0 then
     g_axis_manager_x.r_transf_acc := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_transf_dec <= 0.0 then
     g_axis_manager_x.r_transf_dec := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_transf_vel <= 0.0 then
     g_axis_manager_x.r_transf_vel := axis_x.maxspeed;
  END_IF;
  if g_axis_manager_x.r_jog_acc <= 0.0 then
     g_axis_manager_x.r_jog_acc := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_jog_dec <= 0.0 then
     g_axis_manager_x.r_jog_dec := axis_x.maxacc;
  END_IF;
  if g_axis_manager_x.r_jog_vel <= 0.0 then
     g_axis_manager_x.r_jog_vel := axis_x.maxspeed;
  END_IF;
  if g_b_moving_x then
     (* force re-homing *)
     g_axis_manager_x.b_homed := false;
  END_IF;
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_y.modeProf      := 0;
  (* Max speed units per seconds, 20000 millmeters = 20 meters per second *)
  axis_y.maxSpeed      := 20000.0 / 60.0;
  (* Maximum acceleration *)
  axis_y.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_y.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_y.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_y.coe_enc <= 0.0) or (axis_y.coe_enc > 0.0)) then
    axis_y.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_y.simul         := false;
  (* setting up cubic interpolation *)
  axis_y.intrate       := 5;
  axis_y.segtime       := 0.02;
  (* set point, target position *)
  axis_y.ref_to_rawOut := ref(g_di_rawOutY);
  (* actual position *)
  axis_y.ref_to_rawIn  := ref(g_di_rawInY);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_y.axis_ref  := ref(axis_y);
  g_axis_manager_y.axis_ref := ref(axis_y);
  (* software limit switch *)
  axis_y.posRv := -2000.0;
  axis_y.posFw := 2000.0;
  (* check for axis acceleration value *)
  if g_axis_manager_y.r_homing_acc <= 0.0 then
     g_axis_manager_y.r_homing_acc := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_homing_dec <= 0.0 then
     g_axis_manager_y.r_homing_dec := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_homing_vel <= 0.0 then
     g_axis_manager_y.r_homing_vel := axis_y.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_y.r_transf_acc <= 0.0 then
     g_axis_manager_y.r_transf_acc := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_transf_dec <= 0.0 then
     g_axis_manager_y.r_transf_dec := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_transf_vel <= 0.0 then
     g_axis_manager_y.r_transf_vel := axis_y.maxspeed;
  END_IF;
  if g_axis_manager_y.r_jog_acc <= 0.0 then
     g_axis_manager_y.r_jog_acc := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_jog_dec <= 0.0 then
     g_axis_manager_y.r_jog_dec := axis_y.maxacc;
  END_IF;
  if g_axis_manager_y.r_jog_vel <= 0.0 then
     g_axis_manager_y.r_jog_vel := axis_y.maxspeed;
  END_IF;
  if g_b_moving_y then
     (* force re-homing *)
     g_axis_manager_y.b_homed := false;
  END_IF;
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_z.modeProf      := 0;
  (* Max speed units per seconds, 20000 millmeters = 20 meters per second *)
  axis_z.maxSpeed      := 20000.0 / 60.0;
  (* Maximum acceleration *)
  axis_z.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_z.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_z.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_z.coe_enc <= 0.0) or (axis_z.coe_enc > 0.0)) then
    axis_z.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_z.simul         := false;
  (* setting up cubic interpolation *)
  axis_z.intrate       := 5;
  axis_z.segtime       := 0.02;
  (* set point, target position *)
  axis_z.ref_to_rawOut := ref(g_di_rawOutZ);
  (* actual position *)
  axis_z.ref_to_rawIn  := ref(g_di_rawInZ);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_z.axis_ref  := ref(axis_z);
  g_axis_manager_z.axis_ref := ref(axis_z);
  (* software limit switch *)
  axis_z.posRv := -20000.0;
  axis_z.posFw := 20000.0;
  (* check for axis acceretation value *)
  if g_axis_manager_z.r_homing_acc <= 0.0 then
     g_axis_manager_z.r_homing_acc := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_homing_dec <= 0.0 then
     g_axis_manager_z.r_homing_dec := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_homing_vel <= 0.0 then
     g_axis_manager_z.r_homing_vel := axis_z.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_z.r_transf_acc <= 0.0 then
     g_axis_manager_z.r_transf_acc := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_transf_dec <= 0.0 then
     g_axis_manager_z.r_transf_dec := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_transf_vel <= 0.0 then
     g_axis_manager_z.r_transf_vel := axis_z.maxspeed;
  END_IF;
  if g_axis_manager_z.r_jog_acc <= 0.0 then
     g_axis_manager_z.r_jog_acc := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_jog_dec <= 0.0 then
     g_axis_manager_z.r_jog_dec := axis_z.maxacc;
  END_IF;
  if g_axis_manager_z.r_jog_vel <= 0.0 then
     g_axis_manager_z.r_jog_vel := axis_z.maxspeed;
  END_IF;
  if g_b_moving_z then
     (* force re-homing *)
     g_axis_manager_z.b_homed := false;
  END_IF;
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_a.modeProf      := 0;
  (* Max speed units per seconds, 100 rpm *)   
  axis_a.maxSpeed      := 100.0 * 360.0 / 60.0;
  (* Maximum acceleration *)
  axis_a.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_a.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_a.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_a.coe_enc <= 0.0) or (axis_a.coe_enc > 0.0)) then
    axis_a.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_a.simul         := false;
  (* setting up cubic interpolation *)
  axis_a.intrate       := 5;
  axis_a.segtime       := 0.02;
  (* set point, target position *)
  axis_a.ref_to_rawOut := ref(g_di_rawOutA);
  (* actual position *)
  axis_a.ref_to_rawIn  := ref(g_di_rawInA);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_a.axis_ref  := ref(axis_a);
  g_axis_manager_a.axis_ref := ref(axis_a);
  (* software limit switch *)
  axis_a.posRv := -9999999.0;
  axis_a.posFw := +9999999.0;
  (* check for axis acceleration value *)
  if g_axis_manager_a.r_homing_acc <= 0.0 then
     g_axis_manager_a.r_homing_acc := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_homing_dec <= 0.0 then
     g_axis_manager_a.r_homing_dec := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_homing_vel <= 0.0 then
     g_axis_manager_a.r_homing_vel := axis_a.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_a.r_transf_acc <= 0.0 then
     g_axis_manager_a.r_transf_acc := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_transf_dec <= 0.0 then
     g_axis_manager_a.r_transf_dec := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_transf_vel <= 0.0 then
     g_axis_manager_a.r_transf_vel := axis_a.maxspeed;
  END_IF;
  if g_axis_manager_a.r_jog_acc <= 0.0 then
     g_axis_manager_a.r_jog_acc := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_jog_dec <= 0.0 then
     g_axis_manager_a.r_jog_dec := axis_a.maxacc;
  END_IF;
  if g_axis_manager_a.r_jog_vel <= 0.0 then
     g_axis_manager_a.r_jog_vel := axis_a.maxspeed;
  END_IF;
  if g_b_moving_a then
     (* force re-homing *)
     g_axis_manager_a.b_homed := false;
  END_IF;
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_b.modeProf      := 0;
  (* Max speed units per seconds, 100 rpm *)   
  axis_b.maxSpeed      := 100.0 * 360.0 / 60.0;
  (* Maximum acceleration *)
  axis_b.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_b.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_b.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_b.coe_enc <= 0.0) or (axis_b.coe_enc > 0.0)) then
    axis_b.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_b.simul         := false;
  (* setting up cubic interpolation *)
  axis_b.intrate       := 5;
  axis_b.segtime       := 0.02;
  (* set point, target position *)
  axis_b.ref_to_rawOut := ref(g_di_rawOutB);
  (* actual position *)                    
  axis_b.ref_to_rawIn  := ref(g_di_rawInB);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_b.axis_ref  := ref(axis_b);
  g_axis_manager_b.axis_ref := ref(axis_b);
  (* software limit switch *)
  axis_b.posRv  := -9999999.0;
  axis_b.posFw  := +9999999.0;
  (* check for axis acceleration value *)
  if g_axis_manager_b.r_homing_acc <= 0.0 then
     g_axis_manager_b.r_homing_acc := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_homing_dec <= 0.0 then
     g_axis_manager_b.r_homing_dec := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_homing_vel <= 0.0 then
     g_axis_manager_b.r_homing_vel := axis_b.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_b.r_transf_acc <= 0.0 then
     g_axis_manager_b.r_transf_acc := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_transf_dec <= 0.0 then
     g_axis_manager_b.r_transf_dec := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_transf_vel <= 0.0 then
     g_axis_manager_b.r_transf_vel := axis_b.maxspeed;
  END_IF;
  if g_axis_manager_b.r_jog_acc <= 0.0 then
     g_axis_manager_b.r_jog_acc := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_jog_dec <= 0.0 then
     g_axis_manager_b.r_jog_dec := axis_b.maxacc;
  END_IF;
  if g_axis_manager_b.r_jog_vel <= 0.0 then
     g_axis_manager_b.r_jog_vel := axis_b.maxspeed;
  END_IF;
  if g_b_moving_b then
     (* force re-homing *)
     g_axis_manager_b.b_homed := false;
  END_IF;
  
  (* profile mode 0=position mode, 1=velocity mode *)
  axis_c.modeProf      := 0;
  (* Max speed units per seconds, 100 rpm *)   
  axis_c.maxSpeed      := 100.0 * 360.0 / 60.0;
  (* Maximum acceleration *)
  axis_c.maxAcc        := 2000.0;
  (* Tolerance on position, one millimeter *) 
  axis_b.istPos        := 1.0;
  (* Maximum following error and static error *)
  axis_c.errDin        := 5.0;
  (* Encoder coefficient, one millimeter = encoder pulse * coefficient *)
  if ((axis_c.coe_enc <= 0.0) or (axis_c.coe_enc > 0.0)) then
    axis_c.coe_enc := 0.001;
  END_IF;
  (* turn off simulation on axis *)
  axis_c.simul         := false;
  (* setting up cubic interpolation *)
  axis_c.intrate       := 5;
  axis_c.segtime       := 0.02;
  (* set point, target position *)
  axis_c.ref_to_rawOut := ref(g_di_rawOutC);
  (* actual position *)                    
  axis_c.ref_to_rawIn  := ref(g_di_rawInC);
  (* global function block to manage axis reset and power ON *)
  fb_reset_axis_c.axis_ref  := ref(axis_c);
  g_axis_manager_c.axis_ref := ref(axis_c);
  (* software limit switch *)
  axis_c.posRv  := -9999999.0;
  axis_c.posFw  := +9999999.0;
  (* check for axis acceleration value *)
  if g_axis_manager_c.r_homing_acc <= 0.0 then
     g_axis_manager_c.r_homing_acc := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_homing_dec <= 0.0 then
     g_axis_manager_c.r_homing_dec := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_homing_vel <= 0.0 then
     g_axis_manager_c.r_homing_vel := axis_c.maxspeed * 0.05;
  END_IF;
  if g_axis_manager_c.r_transf_acc <= 0.0 then
     g_axis_manager_c.r_transf_acc := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_transf_dec <= 0.0 then
     g_axis_manager_c.r_transf_dec := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_transf_vel <= 0.0 then
     g_axis_manager_c.r_transf_vel := axis_c.maxspeed;
  END_IF;
  if g_axis_manager_c.r_jog_acc <= 0.0 then
     g_axis_manager_c.r_jog_acc := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_jog_dec <= 0.0 then
     g_axis_manager_c.r_jog_dec := axis_c.maxacc;
  END_IF;
  if g_axis_manager_c.r_jog_vel <= 0.0 then
     g_axis_manager_c.r_jog_vel := axis_c.maxspeed;
  END_IF;
  if g_b_moving_c then
     (* force re-homing *)
     g_axis_manager_c.b_homed := false;
  END_IF;
  
  if g_b_simulation then
     g_b_driverXOk := true;
     g_b_driverYOk := true;
     g_b_driverZOk := true;
     g_b_driverAOk := true;
     g_b_driverBOk := true;
     g_b_driverCOk := true;
  
     g_axis_manager_x.b_homed := true;
     g_axis_manager_y.b_homed := true;
     g_axis_manager_z.b_homed := true;
     g_axis_manager_a.b_homed := true;
     g_axis_manager_b.b_homed := true;
     g_axis_manager_c.b_homed := true;
  
     g_axis_manager_x.b_home_probe := true;
     g_axis_manager_y.b_home_probe := true;
     g_axis_manager_z.b_home_probe := true;
     g_axis_manager_a.b_home_probe := true;
     g_axis_manager_b.b_home_probe := true;
     g_axis_manager_c.b_home_probe := true;
  
     axis_x.FCFW := false;
     axis_y.FCFW := false;
     axis_z.FCFW := false;
     axis_a.FCFW := false;
     axis_b.FCFW := false;
     axis_c.FCFW := false;
  
     axis_x.FCRV := false;
     axis_y.FCRV := false;
     axis_z.FCRV := false;
     axis_a.FCRV := false;
     axis_b.FCRV := false;
     axis_c.FCRV := false;
  
     g_b_stop_auto := true;
  
     TARGET_DEB_I0.SIMUL := true;
     
     else
     g_axis_manager_x.b_homed := true;
     g_axis_manager_y.b_homed := true;
     g_axis_manager_z.b_homed := true;
     g_axis_manager_a.b_homed := true;
     g_axis_manager_b.b_homed := true;
     g_axis_manager_c.b_homed := true;
  END_IF;
  
  cnc_exec_fb.acceleration := axis_x.maxacc;
  cnc_exec_fb.deceleration := axis_x.maxacc;
  cnc_exec_fb.rapidSpeed   := axis_x.maxSpeed;
END_PROGRAM

PROGRAM Main
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    fb_reset_axis_x:  FB_RESET_AXIS;
    fb_reset_axis_y:  FB_RESET_AXIS;
    fb_reset_axis_z:  FB_RESET_AXIS;
    fb_reset_axis_a:  FB_RESET_AXIS;
    fb_reset_axis_b:  FB_RESET_AXIS;
    fb_reset_axis_c:  FB_RESET_AXIS;
    g_r_gui_x_spd:  REAL;
    g_r_gui_y_spd:  REAL;
    g_r_gui_z_spd:  REAL;
    g_r_gui_a_spd:  REAL;
    g_r_gui_b_spd:  REAL;
    g_r_gui_c_spd:  REAL;
    g_b_homing_x:  BOOL;
    g_b_homing_y:  BOOL;
    g_b_homing_z:  BOOL;
    g_b_homing_a:  BOOL;
    g_b_homing_b:  BOOL;
    g_b_homing_c:  BOOL;
    g_b_auto:  BOOL;
    g_b_reset_stop_causes:  BOOL;
    g_b_reset_alarms:  BOOL;
    g_b_start_auto:  BOOL;
    g_b_stop_auto:  BOOL;
    g_b_alarm_stop_auto:  BOOL;
    g_b_alarm_moving:  BOOL;
    g_b_on_auto_x:  BOOL;
    g_b_on_auto_y:  BOOL;
    g_b_on_auto_z:  BOOL;
    g_b_on_auto_a:  BOOL;
    g_b_on_auto_b:  BOOL;
    g_b_on_auto_c:  BOOL;
    g_b_stop_auto_triggered:  BOOL;
    g_b_start_cnc:  BOOL;
  END_VAR
  VAR_EXTERNAL
    g_b_moving_x:  BOOL;
    g_b_moving_y:  BOOL;
    g_b_moving_z:  BOOL;
    g_b_moving_a:  BOOL;
    g_b_moving_b:  BOOL;
    g_b_moving_c:  BOOL;
    g_axis_manager_x:  FB_AXIS_MANAGER;
    g_axis_manager_y:  FB_AXIS_MANAGER;
    g_axis_manager_z:  FB_AXIS_MANAGER;
    g_axis_manager_a:  FB_AXIS_MANAGER;
    g_axis_manager_b:  FB_AXIS_MANAGER;
    g_axis_manager_c:  FB_AXIS_MANAGER;
  END_VAR
  VAR
    old_moving:  BOOL;
    flush_sram:  BOOL;
    r_trig_auto:  R_TRIG;
    f_trig_man:  R_TRIG;
  END_VAR

  (* wait for atomatic cicle start *)
  r_trig_auto(clk := g_b_start_auto);
  if r_trig_auto.q then
    (* stop button pressed ? *)
    if not g_b_stop_auto then
       g_b_alarm_stop_auto := true;
    else
       (* all axes are in standstill Motion state *)
       if (fb_reset_axis_x.fb_status.standstill and
           fb_reset_axis_y.fb_status.standstill and
           fb_reset_axis_z.fb_status.standstill and
           fb_reset_axis_a.fb_status.standstill and
           fb_reset_axis_b.fb_status.standstill and
           fb_reset_axis_c.fb_status.standstill) then
          g_b_reset_stop_causes := true;
          g_b_reset_alarms      := true;
          (*
            when we are in GUI axes pages that manage axes :
             - g_b_on_auto_? is true
               - x_management.ui -> qhmisetwidgetstate
             - g_b_homing_? is true we want to command an homing cicle 
               - x_management.ui -> qHmiSwitch_2
             - g_b_homing_? is false we want to command a transfer cicle 
               - x_management.ui -> qHmiSwitch_2
          *)
          if g_b_on_auto_x then
             if g_b_homing_x then
                g_axis_manager_x.b_homed        := false;
                g_axis_manager_x.b_start_homing := true;
             else
                g_axis_manager_x.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          elsif g_b_on_auto_y then
             if g_b_homing_y then
                g_axis_manager_y.b_homed        := false;
                g_axis_manager_y.b_start_homing := true;
             else
                g_axis_manager_y.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          elsif g_b_on_auto_z then
             if g_b_homing_z then
                g_axis_manager_z.b_homed        := false;
                g_axis_manager_z.b_start_homing := true;
             else
                g_axis_manager_z.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          elsif g_b_on_auto_a then
             if g_b_homing_a then
                g_axis_manager_a.b_homed        := false;
                g_axis_manager_a.b_start_homing := true;
             else
                g_axis_manager_a.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          elsif g_b_on_auto_b then
             if g_b_homing_b then
                g_axis_manager_b.b_homed        := false;
                g_axis_manager_b.b_start_homing := true;
             else
                g_axis_manager_b.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          elsif g_b_on_auto_c then
             if g_b_homing_c then
                g_axis_manager_c.b_homed        := false;
                g_axis_manager_c.b_start_homing := true;
             else
                g_axis_manager_c.b_start_transf := true;
             END_IF;
            g_b_auto := true;
          else
            g_b_start_cnc := true;                  
            g_b_auto := true;
          END_IF;
       else
          g_b_alarm_moving := true;
      END_IF;
    END_IF;
  END_IF;
             
  (* wait for atomatic cicle stop *)
  f_trig_man(clk := g_b_stop_auto);
  if f_trig_man.q then
    g_b_auto      := false;
    g_b_start_cnc := false;
    
    g_axis_manager_x.b_start_homing := false;
    g_axis_manager_x.b_start_transf := false;
    g_axis_manager_y.b_start_homing := false;
    g_axis_manager_y.b_start_transf := false;
    g_axis_manager_z.b_start_homing := false;
    g_axis_manager_z.b_start_transf := false;
    g_axis_manager_a.b_start_homing := false;
    g_axis_manager_a.b_start_transf := false;
    g_axis_manager_b.b_start_homing := false;
    g_axis_manager_b.b_start_transf := false;
    g_axis_manager_c.b_start_homing := false;
    g_axis_manager_c.b_start_transf := false;
    
    g_b_stop_auto_triggered := true;
  END_IF;
  
  flush_sram := false;
  (* hold X axis moving condition *)
  old_moving := g_b_moving_x;
  if (axis_x.realspeed <> 0.0) then
     g_r_gui_x_spd := ABS(axis_x.realspeed) * 60.0;
     g_b_moving_x := true;
  else
      g_r_gui_x_spd := 0.0;
     g_b_moving_x := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_x);
  
  (* hold Y axis moving condition *)
  old_moving := g_b_moving_y;
  if (axis_y.realspeed <> 0.0) then
     g_r_gui_y_spd := ABS(axis_y.realspeed) * 60.0;
     g_b_moving_y := true;
  else
      g_r_gui_y_spd := 0.0;
     g_b_moving_y := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_y);
  
  (* hold Z axis moving condition *)
  old_moving := g_b_moving_z;
  if (axis_z.realspeed <> 0.0) then
     g_r_gui_z_spd := ABS(axis_z.realspeed) * 60.0;
     g_b_moving_z := true;
  else
      g_r_gui_z_spd := 0.0;
     g_b_moving_z := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_z);
  
  (* hold A axis moving condition *)
  old_moving := g_b_moving_a;
  if (axis_y.realspeed <> 0.0) then
     g_r_gui_a_spd := ABS(axis_a.realspeed) * 60.0;
     g_b_moving_a := true;
  else
      g_r_gui_a_spd := 0.0;
     g_b_moving_a := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_a);
  
  (* hold B axis moving condition *)
  old_moving := g_b_moving_b;
  if (axis_b.realspeed <> 0.0) then
     g_r_gui_b_spd := ABS(axis_b.realspeed) * 60.0;
     g_b_moving_b := true;
  else
      g_r_gui_b_spd := 0.0;
     g_b_moving_b := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_b);
  
  (* hold C axis moving condition *)
  old_moving := g_b_moving_c;
  if (axis_c.realspeed <> 0.0) then
     g_r_gui_c_spd := ABS(axis_c.realspeed) * 60.0;
     g_b_moving_c := true;
  else
      g_r_gui_c_spd := 0.0;
     g_b_moving_c := false;
  END_IF;
  flush_sram := flush_sram or (old_moving <> g_b_moving_c);
  
  if flush_sram then
     flush_sram := false;
     (* force static ram refresh *)
     retainFlush();
  END_IF;
END_PROGRAM

FUNCTION parse_number : STRING
  VAR
    char:  string;
    finish:  BOOL;
  END_VAR
  VAR_INPUT
    p_s:  REF_TO CNC_PARSER_STRUCT;
    current:  USINT;
  END_VAR

  while (not finish) do
    char := mid(p_s^.in, 1, current + 1);
    if (char = '0') or
       (char = '1') or
       (char = '2') or
       (char = '3') or
       (char = '4') or
       (char = '5') or
       (char = '6') or
       (char = '7') or
       (char = '8') or
       (char = '9') or
       (char = '+') or
       (char = '-') or
       (char = '.') then
       parse_number := concat(parse_number, char);
       current := current + 1;
    else
      finish := true;
    END_IF;
  
  p_s^.POSITION := current; 
  
  END_WHILE;
END_FUNCTION

FUNCTION parser_callback : VOID
  VAR
    t_word_found:  BOOL := false;
    number:  string;
    position:  USINT;
  END_VAR
  VAR_INPUT
    p_s:  REF_TO CNC_PARSER_STRUCT;
  END_VAR

  (* delete 'G69' command from GCode *)
  position := find (p_s^.in, 'G69');
  if (position <> 0) then
    p_s^.in := delete (p_s^.in, 3, position);
  END_IF;
END_FUNCTION

PROGRAM power_on_axis
  VAR_EXTERNAL
    TARGET_DEB_I0:  TARGET_DEB_T;
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    fb_reset_axis_x:  FB_RESET_AXIS;
    fb_reset_axis_y:  FB_RESET_AXIS;
    fb_reset_axis_z:  FB_RESET_AXIS;
    fb_reset_axis_a:  FB_RESET_AXIS;
    fb_reset_axis_b:  FB_RESET_AXIS;
    fb_reset_axis_c:  FB_RESET_AXIS;
    g_b_driverXOk:  BOOL;
    g_b_driverYOk:  BOOL;
    g_b_driverZOk:  BOOL;
    g_b_driverAOk:  BOOL;
    g_b_driverBOk:  BOOL;
    g_b_driverCOk:  BOOL;
    g_b_machineOk:  BOOL;
    g_b_reset_axis:  BOOL;
    g_b_reset_stop_causes:  BOOL;
    g_b_driversEnable:  BOOL;
  END_VAR

  (* Axes drivers enable *)
  g_b_driversEnable :=  g_b_machineOk;
  
  (* MOTION : X axis reset and power on management *)
  fb_reset_axis_x.b_power := g_b_driversEnable;
  fb_reset_axis_x.b_reset := g_b_reset_axis;
  fb_reset_axis_x();
  axis_x.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_x.recvPower := g_b_driverXOk;
  axis_x.recvReset := axis_x.sendReset;
  axis_x.drvok     := g_b_driverXOk;
  
  (* MOTION : Y axis reset and power on management *)
  fb_reset_axis_y.b_power := g_b_driversEnable;
  fb_reset_axis_y.b_reset := g_b_reset_axis;
  fb_reset_axis_y();
  axis_y.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_y.recvPower := g_b_driverYOk;
  axis_y.recvReset := axis_y.sendReset;
  axis_y.drvok     := g_b_driverYOk;
  
  (* MOTION : Z axis reset and power on management *)
  fb_reset_axis_z.b_power := g_b_driversEnable;
  fb_reset_axis_z.b_reset := g_b_reset_axis;
  fb_reset_axis_z();
  axis_z.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_z.recvPower := g_b_driverZOk;
  axis_z.recvReset := axis_z.sendReset;
  axis_z.drvok     := g_b_driverZOk;
  
  (* MOTION : A axis reset and power on management *)
  fb_reset_axis_a.b_power := g_b_driversEnable;
  fb_reset_axis_a.b_reset := g_b_reset_axis;
  fb_reset_axis_a();
  axis_a.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_a.recvPower := g_b_driverAOk;
  axis_a.recvReset := axis_a.sendReset;
  axis_a.drvok     := g_b_driverAOk;
  
  (* MOTION : B axis reset and power on management *)
  fb_reset_axis_b.b_power := g_b_driversEnable;
  fb_reset_axis_b.b_reset := g_b_reset_axis;
  fb_reset_axis_b();
  axis_b.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_b.recvPower := g_b_driverBOk;
  axis_b.recvReset := axis_b.sendReset;
  axis_b.drvok     := g_b_driverBOk;
  
  (* MOTION : C axis reset and power on management *)
  fb_reset_axis_c.b_power := g_b_driversEnable;
  fb_reset_axis_c.b_reset := g_b_reset_axis;
  fb_reset_axis_c();
  axis_c.en_enc    := TARGET_DEB_I0.DEBOK;
  axis_c.recvPower := g_b_driverCOk;
  axis_c.recvReset := axis_c.sendReset;
  axis_c.drvok     := g_b_driverCOk;
  
  if g_b_reset_axis then
     g_b_reset_stop_causes := g_b_reset_axis;
  END_IF;   
  g_b_reset_axis := false;
END_PROGRAM

PROGRAM slow_cnc
  VAR
    b_alarm_bound:  BOOL;
    b_alarm_cnc_not_load:  BOOL;
    b_cnc_reset:  BOOL;
    i:  INT;
    b_cnc_load:  BOOL := true;
    low_bounds:  CNC_AXES_POSITIONS;
    high_bounds:  CNC_AXES_POSITIONS;
    cnc_translate_fb:  CNC_TRANSLATE;
  END_VAR
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    g_b_auto:  BOOL;
    cnc_parser_fb:  CNC_PARSER;
    cnc_read_fb:  CNC_READFILE;
  END_VAR
  VAR_EXTERNAL
    cnc_exec_fb:  CNC_EXECGCODE;
    g_b_need_reset:  BOOL;
  END_VAR
  VAR  RETAIN
    cnc_filename:  string;
    s_gCode_boundary_x:  string;
    s_gCode_boundary_y:  string;
    s_gCode_boundary_z:  string;
    s_gCode_boundary_a:  string;
    s_gCode_boundary_b:  string;
    s_gCode_boundary_c:  string;
    s_cnc_line_1:  string;
    s_cnc_line_2:  string;
    s_cnc_line_3:  string;
    displaceOrigin:  BOOL;
  END_VAR

  (* https://en.wikipedia.org/wiki/G-code *)
  
  (* 
  GCode intepreter start from HMI
  refer to :
  filesystem.js -> buttonCliched
  *)
  if cnc_parser_fb.execute then
     cnc_parser_fb.filename := cnc_filename;
     cnc_parser_fb();
  
     (* 
       g_b_need_reset = true means what whe have to reset the work
       refer to :
       default_800x480.ui -> QHmiButtonResetWork
      *)
     g_b_need_reset := true;   
     
     cnc_parser_fb.execute := false;
     cnc_parser_fb();
     
     (* succesfully parsed ? *)
     b_cnc_load := cnc_parser_fb.done;
  END_IF;
     
  (* load preinterpreted binay file *)
  if b_cnc_load then
     (* logical GCode movement to physical axis *)
     cnc_exec_fb.axes[0] := axis_x.axisIdx;
     cnc_exec_fb.axes[1] := axis_y.axisIdx;
     cnc_exec_fb.axes[2] := axis_z.axisIdx;
     cnc_exec_fb.axes[3] := axis_a.axisIdx;
     cnc_exec_fb.axes[4] := axis_b.axisIdx;
     cnc_exec_fb.axes[5] := axis_c.axisIdx;
  
     cnc_read_fb.filename := cnc_filename;
     cnc_read_fb.execute  := true;
     cnc_read_fb();
   
     cnc_read_fb.execute := false;
     cnc_read_fb();
     
     b_cnc_load := false;
  END_IF;
  
  if b_cnc_reset then
    b_cnc_reset := false;
    (* succesfully load *)
    if cnc_read_fb.done then
       if displaceOrigin then
          (* translate the GCode to the actual position *)
          cnc_translate_fb.LINEINFO     := cnc_read_fb.lineinfo;
          cnc_translate_fb.LINEINFO_LEN := cnc_read_fb.lineinfo_len;
          cnc_translate_fb.TRANSLATETO[0] := lreal_to_real(axis_x.abspos);
          cnc_translate_fb.TRANSLATETO[1] := lreal_to_real(axis_y.abspos);
          cnc_translate_fb.TRANSLATETO[2] := lreal_to_real(axis_z.abspos);
          cnc_translate_fb.TRANSLATETO[3] := lreal_to_real(axis_a.abspos);
          cnc_translate_fb.TRANSLATETO[4] := lreal_to_real(axis_b.abspos);
          cnc_translate_fb.TRANSLATETO[5] := lreal_to_real(axis_c.abspos);
          cnc_translate_fb(EXECUTE := true);
          cnc_translate_fb(EXECUTE := false);
       END_IF;
       
       (* calculate machining bounding box *)
       for  i:= 0 to 8 by 1 do
         low_bounds[i]  := cnc_read_fb.LOWBOUND[i] + cnc_translate_fb.TRANSLATETO[i];
         high_bounds[i] := cnc_read_fb.HIGHBOUND[i] + cnc_translate_fb.TRANSLATETO[i];
       END_FOR;
       
       b_alarm_bound := false;
       
       (* 
         fill string with bounding box for HMI
         refer to:
         alarms.ui -> cnc TAB -> GCode boundaries sections
       *)
       s_gCode_boundary_x := real_to_string(low_bounds[0]);
       s_gCode_boundary_x := concat(s_gCode_boundary_x, ' <-> ');
       s_gCode_boundary_x := concat(s_gCode_boundary_x, real_to_string(high_bounds[0]));
       (* check if machining is inside software limit switch *)
       if ((low_bounds[0]  < axis_x.posRv) or
          (low_bounds[0]  > axis_x.posFw) or
          (high_bounds[0] < axis_x.posRv) or
          (high_bounds[0] > axis_x.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       s_gCode_boundary_y := real_to_string(low_bounds[1]);
       s_gCode_boundary_y := concat(s_gCode_boundary_y, ' <-> ');
       s_gCode_boundary_y := concat(s_gCode_boundary_y, real_to_string(high_bounds[1]));
       if ((low_bounds[1]  < axis_y.posRv) or
          (low_bounds[1]  > axis_y.posFw) or
          (high_bounds[1] < axis_y.posRv) or
          (high_bounds[1] > axis_y.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       s_gCode_boundary_z := real_to_string(low_bounds[2]);
       s_gCode_boundary_z := concat(s_gCode_boundary_z, ' <-> ');
       s_gCode_boundary_z := concat(s_gCode_boundary_z, real_to_string(high_bounds[2]));
       if ((low_bounds[2]  < axis_z.posRv) or
          (low_bounds[2]  > axis_z.posFw) or
          (high_bounds[2] < axis_z.posRv) or
          (high_bounds[2] > axis_z.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       s_gCode_boundary_a := real_to_string(low_bounds[3]);
       s_gCode_boundary_a := concat(s_gCode_boundary_a, ' <-> ');
       s_gCode_boundary_a := concat(s_gCode_boundary_a, real_to_string(high_bounds[3]));
       if ((low_bounds[3]  < axis_a.posRv) or
          (low_bounds[3]  > axis_a.posFw) or
          (high_bounds[3] < axis_a.posRv) or
          (high_bounds[3] > axis_a.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       s_gCode_boundary_b := real_to_string(low_bounds[4]);
       s_gCode_boundary_b := concat(s_gCode_boundary_b, ' <-> ');
       s_gCode_boundary_b := concat(s_gCode_boundary_b, real_to_string(high_bounds[4]));
       if ((low_bounds[4]  < axis_b.posRv) or
          (low_bounds[4]  > axis_b.posFw) or
          (high_bounds[4] < axis_b.posRv) or
          (high_bounds[4] > axis_b.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       s_gCode_boundary_c := real_to_string(low_bounds[5]);
       s_gCode_boundary_c := concat(s_gCode_boundary_c, ' <-> ');
       s_gCode_boundary_c := concat(s_gCode_boundary_c, real_to_string(high_bounds[5]));
       if ((low_bounds[5]  < axis_c.posRv) or
          (low_bounds[5]  > axis_c.posFw) or
          (high_bounds[5] < axis_c.posRv) or
          (high_bounds[5] > axis_c.posFw)) then
          b_alarm_bound := true;
       END_IF;
       
       if (b_alarm_bound = false) then
          g_b_need_reset := false;
          cnc_exec_fb.reset := true;
       END_IF;
    else
       b_alarm_cnc_not_load := true;
    END_IF;
  END_IF;
  
  (* pass to GCode execute FB the readed program *)
  cnc_exec_fb.lineInfo     := cnc_read_fb.lineInfo;
  cnc_exec_fb.lineInfo_len := cnc_read_fb.lineInfo_len;
  cnc_exec_fb();
  if cnc_exec_fb.error then
     g_b_auto := false;
  END_IF;
  cnc_exec_fb.execute := false;
  cnc_exec_fb.stop := false;
  
  (* 
    fill three string with the GCode we are executing for HMI
    refer to :
    alarms.ui -> cnc TAB
  *)
  s_cnc_line_1 := CNC_GETLINESTRING(ref(cnc_exec_fb), cnc_exec_fb.gCodeLine - 1);
  s_cnc_line_2 := CNC_GETLINESTRING(ref(cnc_exec_fb), cnc_exec_fb.gCodeLine);
  s_cnc_line_3 := CNC_GETLINESTRING(ref(cnc_exec_fb), cnc_exec_fb.gCodeLine + 1);
END_PROGRAM

PROGRAM slow_operations
  VAR_EXTERNAL
    g_si_verbose:  SINT;
    g_axis_manager_x:  FB_AXIS_MANAGER;
    g_axis_manager_y:  FB_AXIS_MANAGER;
    g_axis_manager_z:  FB_AXIS_MANAGER;
    g_axis_manager_a:  FB_AXIS_MANAGER;
    g_axis_manager_b:  FB_AXIS_MANAGER;
    g_axis_manager_c:  FB_AXIS_MANAGER;
    cnc_exec_fb:  CNC_EXECGCODE;
  END_VAR
  VAR_EXTERNAL
    AXIS_X:  AXIS_REF_T;
    AXIS_Y:  AXIS_REF_T;
    AXIS_Z:  AXIS_REF_T;
    AXIS_A:  AXIS_REF_T;
    AXIS_B:  AXIS_REF_T;
    AXIS_C:  AXIS_REF_T;
    g_b_machineOk:  BOOL;
    g_b_homing_x:  BOOL;
    g_b_homing_y:  BOOL;
    g_b_homing_z:  BOOL;
    g_b_homing_a:  BOOL;
    g_b_homing_b:  BOOL;
    g_b_homing_c:  BOOL;
    g_b_auto:  BOOL;
    g_b_man:  BOOL;
    g_b_start_cnc:  BOOL;
  END_VAR

  (* Motion verbose level *)
  axis_x.verbose := g_si_verbose;
  axis_y.verbose := g_si_verbose;
  axis_z.verbose := g_si_verbose;
  axis_a.verbose := g_si_verbose;
  axis_b.verbose := g_si_verbose;
  axis_c.verbose := g_si_verbose;
  
  (* check for automatic terminated cicles *)
  if g_b_auto then
    if ((not g_axis_manager_x.b_start_homing) and (not g_axis_manager_x.b_start_transf) and
        (not g_axis_manager_y.b_start_homing) and (not g_axis_manager_y.b_start_transf) and
        (not g_axis_manager_z.b_start_homing) and (not g_axis_manager_z.b_start_transf) and
        (not g_axis_manager_a.b_start_homing) and (not g_axis_manager_a.b_start_transf) and
        (not g_axis_manager_b.b_start_homing) and (not g_axis_manager_b.b_start_transf) and
        (not g_axis_manager_c.b_start_homing) and (not g_axis_manager_c.b_start_transf) and
        (not cnc_exec_fb.active)              and (not g_b_start_cnc))                  then
      g_b_auto     := false;
      g_b_homing_x := false;
      g_b_homing_y := false;
      g_b_homing_z := false;
      g_b_homing_a := false;
      g_b_homing_b := false;
      g_b_homing_c := false;
    END_IF;
  END_IF;           
  
  g_b_man := not g_b_auto and g_b_machineOk;
END_PROGRAM

CONFIGURATION conf1
  VAR_GLOBAL RETAIN
    g_si_verbose : SINT;
    g_b_moving_x : BOOL;
    g_b_moving_y : BOOL;
    g_b_moving_z : BOOL;
    g_b_moving_a : BOOL;
    g_b_moving_b : BOOL;
    g_b_moving_c : BOOL;
    g_b_stop_power_off : BOOL;
    g_b_stop_errorstop : BOOL;
    g_b_stop_disabled : BOOL;
    g_b_stop_probeX : BOOL;
    g_b_stop_probeY : BOOL;
    g_b_stop_probeZ : BOOL;
    g_b_stop_probeA : BOOL;
    g_b_stop_probeB : BOOL;
    g_b_stop_probeC : BOOL;
    g_b_stop_rv_ls_X : BOOL;
    g_b_stop_rv_ls_Y : BOOL;
    g_b_stop_rv_ls_Z : BOOL;
    g_b_stop_rv_ls_A : BOOL;
    g_b_stop_rv_ls_B : BOOL;
    g_b_stop_rv_ls_C : BOOL;
    g_b_stop_fw_ls_X : BOOL;
    g_b_stop_fw_ls_Y : BOOL;
    g_b_stop_fw_ls_Z : BOOL;
    g_b_stop_fw_ls_A : BOOL;
    g_b_stop_fw_ls_B : BOOL;
    g_b_stop_fw_ls_C : BOOL;
    g_axis_manager_x : FB_AXIS_MANAGER;
    g_axis_manager_y : FB_AXIS_MANAGER;
    g_axis_manager_z : FB_AXIS_MANAGER;
    g_axis_manager_a : FB_AXIS_MANAGER;
    g_axis_manager_b : FB_AXIS_MANAGER;
    g_axis_manager_c : FB_AXIS_MANAGER;
    cnc_exec_fb : CNC_EXECGCODE;
    g_b_need_reset : BOOL;
  END_VAR
  VAR_GLOBAL
    TARGET_DEB_I0 : TARGET_DEB_T;
    AXIS_X : AXIS_REF_T;
    AXIS_Y : AXIS_REF_T;
    AXIS_Z : AXIS_REF_T;
    AXIS_A : AXIS_REF_T;
    AXIS_B : AXIS_REF_T;
    AXIS_C : AXIS_REF_T;
    SIRIUS_CANBUS_I0 : SIRIUS_CANBUS_T;
    SIO15 : CAN_NODE_T;
    local_di : TARGET_DEB_DI_T;
    local_ai : TARGET_DEB_AI_T;
    local_do : TARGET_DEB_DO_T;
    local_ao : TARGET_DEB_AO_T;
    local_pwm : TARGET_DEB_PWM_T;
    g_b_simulation : BOOL;
    g_di_rawOutX : DINT;
    g_di_rawInX : DINT;
    g_di_rawOutY : DINT;
    g_di_rawInY : DINT;
    g_di_rawOutZ : DINT;
    g_di_rawInZ : DINT;
    g_di_rawOutA : DINT;
    g_di_rawInA : DINT;
    g_di_rawOutB : DINT;
    g_di_rawInB : DINT;
    g_di_rawOutC : DINT;
    g_di_rawInC : DINT;
    fb_reset_axis_x : FB_RESET_AXIS;
    fb_reset_axis_y : FB_RESET_AXIS;
    fb_reset_axis_z : FB_RESET_AXIS;
    fb_reset_axis_a : FB_RESET_AXIS;
    fb_reset_axis_b : FB_RESET_AXIS;
    fb_reset_axis_c : FB_RESET_AXIS;
    g_b_driverXOk : BOOL;
    g_b_driverYOk : BOOL;
    g_b_driverZOk : BOOL;
    g_b_driverAOk : BOOL;
    g_b_driverBOk : BOOL;
    g_b_driverCOk : BOOL;
    g_b_powerOk : BOOL;
    g_b_powerOn : BOOL;
    g_b_machineOk : BOOL;
    g_r_gui_x_spd : REAL;
    g_r_gui_y_spd : REAL;
    g_r_gui_z_spd : REAL;
    g_r_gui_a_spd : REAL;
    g_r_gui_b_spd : REAL;
    g_r_gui_c_spd : REAL;
    g_b_homing_x : BOOL;
    g_b_homing_y : BOOL;
    g_b_homing_z : BOOL;
    g_b_homing_a : BOOL;
    g_b_homing_b : BOOL;
    g_b_homing_c : BOOL;
    g_b_reset_axis : BOOL;
    g_b_auto : BOOL;
    g_b_alarm_power_off : BOOL;
    g_b_alarm_errorstop : BOOL;
    g_b_alarm_disabled : BOOL;
    g_b_alarm_probeX : BOOL;
    g_b_alarm_probeY : BOOL;
    g_b_alarm_probeZ : BOOL;
    g_b_alarm_probeA : BOOL;
    g_b_alarm_probeB : BOOL;
    g_b_alarm_probeC : BOOL;
    g_b_alarm_rv_ls_X : BOOL;
    g_b_alarm_rv_ls_Y : BOOL;
    g_b_alarm_rv_ls_Z : BOOL;
    g_b_alarm_rv_ls_A : BOOL;
    g_b_alarm_rv_ls_B : BOOL;
    g_b_alarm_rv_ls_C : BOOL;
    g_b_alarm_fw_ls_X : BOOL;
    g_b_alarm_fw_ls_Y : BOOL;
    g_b_alarm_fw_ls_Z : BOOL;
    g_b_alarm_fw_ls_A : BOOL;
    g_b_alarm_fw_ls_B : BOOL;
    g_b_alarm_fw_ls_C : BOOL;
    g_b_reset_stop_causes : BOOL;
    g_b_reset_alarms : BOOL;
    g_b_start_auto : BOOL;
    g_b_stop_auto : BOOL;
    g_b_alarm_stop_auto : BOOL;
    g_b_alarm_moving : BOOL;
    g_b_on_auto_x : BOOL;
    g_b_on_auto_y : BOOL;
    g_b_on_auto_z : BOOL;
    g_b_on_auto_a : BOOL;
    g_b_on_auto_b : BOOL;
    g_b_on_auto_c : BOOL;
    g_b_stop_auto_triggered : BOOL;
    g_b_driversEnable : BOOL;
    g_b_alarm_driverXOk : BOOL;
    g_b_alarm_driverYOk : BOOL;
    g_b_alarm_driverZOk : BOOL;
    g_b_alarm_driverAOk : BOOL;
    g_b_alarm_driverBOk : BOOL;
    g_b_alarm_driverCOk : BOOL;
    g_b_man : BOOL;
    cnc_parser_fb : CNC_PARSER;
    cnc_read_fb : CNC_READFILE;
    g_b_start_cnc : BOOL;
    SIO15_RPDO : RPDO_SIO15_T;
    SIO15_TPDO : TPDO_SIO15_T;
  END_VAR

  RESOURCE res1 ON PLC
    TASK Task_12ms(INTERVAL := t#12ms, PRIORITY := 1);
    PROGRAM pou_Main WITH Task_12ms : Main;
    PROGRAM pou_Axes_manager WITH Task_12ms : axes_manager;
    PROGRAM pou_cnc_main WITH Task_12ms : cnc_main;
  END_RESOURCE
END_CONFIGURATION
